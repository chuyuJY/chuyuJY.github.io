<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>并发编程 - Tag - Chuyu&#39;s Blog</title>
        <link>https://blog.seucy.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
        <description>并发编程 - Tag - Chuyu&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>1205667742@qq.com (Chuyu)</managingEditor>
            <webMaster>1205667742@qq.com (Chuyu)</webMaster><lastBuildDate>Wed, 22 Feb 2023 20:13:28 &#43;0800</lastBuildDate><atom:link href="https://blog.seucy.me/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="self" type="application/rss+xml" /><item>
    <title>Go-GMP</title>
    <link>https://blog.seucy.me/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
    <pubDate>Wed, 22 Feb 2023 20:13:28 &#43;0800</pubDate>
    <author>Chuyu</author>
    <guid>https://blog.seucy.me/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
    <description><![CDATA[[toc] 参考文章： Go语言设计与实现 深入了解 Go 语言与并发编程 从 bug 中学习：六大开源项目告诉你 go 并发编程的那些坑 一、Go 并发机制 Go 的调度器使用 G、M、]]></description>
</item>
<item>
    <title>Go-WaitGroup</title>
    <link>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-waitgroup/</link>
    <pubDate>Mon, 20 Feb 2023 20:13:28 &#43;0800</pubDate>
    <author>Chuyu</author>
    <guid>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-waitgroup/</guid>
    <description><![CDATA[一、结构 WaitGroup 的结构很简单，维护了三个不同的计数，分别是 counter、waiter 和 semaphore： counter 记录了要等待结束的 goroutine 个数； waiter 记录了等]]></description>
</item>
<item>
    <title>Go-Context</title>
    <link>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-context/</link>
    <pubDate>Sun, 19 Feb 2023 20:13:28 &#43;0800</pubDate>
    <author>Chuyu</author>
    <guid>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-context/</guid>
    <description><![CDATA[前言：在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC]]></description>
</item>
<item>
    <title>Go-Channel</title>
    <link>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-channel/</link>
    <pubDate>Sat, 18 Feb 2023 20:13:28 &#43;0800</pubDate>
    <author>Chuyu</author>
    <guid>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-channel/</guid>
    <description><![CDATA[[toc] 参考文章： Golang Channel 实现原理 一、核心数据结构 1.1 hchan 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32]]></description>
</item>
<item>
    <title>Go浅析-Atomic</title>
    <link>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-atomic/</link>
    <pubDate>Sat, 18 Feb 2023 20:13:28 &#43;0800</pubDate>
    <author>Chuyu</author>
    <guid>https://blog.seucy.me/go%E6%A0%87%E5%87%86%E5%BA%93-atomic/</guid>
    <description><![CDATA[[toc] 一、Atomic 方法 如果去看文档会发现 atomic 的函数签名有很多，但是大部分都是重复的为了不同的数据类型创建了不同的签名，这就是没有泛型的坏处了，]]></description>
</item>
</channel>
</rss>
